// react_diff_P1.edp
//
// A FreeFEM++ script that shows the MsFEM approach on the vectorial reaction-diffusion problem
//
// This file correspond to the alternative method described in the article
//
// Note that this implementation is possible mainly due to the following in-depth functionality of FreeFEM++:
// - VK(k,i) gives the global degree of freedom of the ith local DOF in the kth triangle of the mesh

//mpirun -np 1 FreeFem++-mpi -wg main_react_diff_MsFEM_OS_square_filtre_bis.edp -v 0

string nameMethod = "MsFEM_OS_carre_filtre_bis";

include "init.edp"

real[int] Amat11(nnzmax); //matrix contributions A[Imat[k],Jmat[k]] = Amat[k], summing all contributions
real[int] Amat12(nnzmax); //matrix contributions A[Imat[k],Jmat[k]] = Amat[k], summing all contributions
real[int] Amat21(nnzmax); //matrix contributions A[Imat[k],Jmat[k]] = Amat[k], summing all contributions
real[int] Amat22(nnzmax); //matrix contributions A[Imat[k],Jmat[k]] = Amat[k], summing all contributions
real[int] Bmat11(nnzmax); //matrix contributions B[Imat[k],Jmat[k]] = Bmat[k], summing all contributions
real[int] Bmat12(nnzmax); //matrix contributions B[Imat[k],Jmat[k]] = Bmat[k], summing all contributions
real[int] Bmat21(nnzmax); //matrix contributions B[Imat[k],Jmat[k]] = Bmat[k], summing all contributions
real[int] Bmat22(nnzmax); //matrix contributions B[Imat[k],Jmat[k]] = Bmat[k], summing all contributions

///////////////////////////////////////////////////////////////////////
// Offline stage                                                     //
// - Computation of multiscale basis functions                       //
// - Computation of stiffness matrix                                 //
//(- The discrete right-hand side is also computed here)             //
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
// - Computation of multiscale basis functions                       //
///////////////////////////////////////////////////////////////////////

printmessage("Construction des fonctions de forme ");

tic = clock();

for (int k=0; k<Ntri; k++) { //Ntri = nombre de triangles du maillage grossier

    vk[][k]=1;
    // Defining the vertices of the ideal oversampling patch (possibly lying partially outside the global domain)
    real[int,int] Kx(3,2); //save coordinates of the vertices belonging to K
    for(int kk=0; kk<3; kk++) {
        Kx(kk,0) = TH[k][kk].x;
        Kx(kk,1) = TH[k][kk].y;
    }
    real[int,int] Sx(3,2); //compute coordinates for the ideal oversampling patch by homothety
    for(int kk=0; kk<3; kk++) {
        Sx(kk,0) = (osCoef)*(Kx(kk,0) - xb[][k]) + xb[][k];
        Sx(kk,1) = (osCoef)*(Kx(kk,1) - yb[][k]) + yb[][k];
    }

    // Construction of a patch-container C around S that is (much) smaller than Omega
    int NxC = Nx/nx;
    int NyC = Ny/ny;

    real xCL = (floor(Sx(:,0).min/hx)-1)*hx; //we take a small margin around the vertices of S as computed above

    real xCR = (ceil(Sx(:,0).max/hx)+1)*hx;

    real yCL = (floor(Sx(:,1).min/hy)-1)*hy;

    real yCR = (ceil(Sx(:,1).max/hy)+1)*hy;

    if (PriseEnCompteBord){

        xCL = max(0.,xCL); //ensure that the patch-container is a subset of the global domain
        xCR = min(Lx, xCR);
        yCL = max(0., yCL);
        yCR = min(Ly, yCR);

            if (CentrePatchCarre){

                real osCoefCentre ;
                real DX = max(abs(Kx(0,0) - xb[][k]),abs(Kx(1,0) - xb[][k]), abs(Kx(2,0) - xb[][k])) ;
                real DY = max(abs(Kx(0,1) - yb[][k]),abs(Kx(1,1) - yb[][k]), abs(Kx(2,1) - yb[][k])) ;
                real OS1 = (xb[][k] - xCL)/abs(Kx(0,0) - xb[][k]);
                osCoefCentre = min(OS1, osCoef);
                real OS2 = (xCR - xb[][k])/abs(Kx(1,0) - xb[][k]) ;
                osCoefCentre = min(OS2, osCoefCentre);
                real OS3 = (yb[][k] - yCL)/abs(Kx(0,1) - yb[][k]) ;
                osCoefCentre = min(OS3, osCoefCentre);
                real OS4 = (yCR - yb[][k])/abs(Kx(2,1) - yb[][k]) ;
                osCoefCentre = min(OS4, osCoefCentre);

                for(int kk=0; kk<3; kk++) {
                    Sx(kk,0) = (osCoefCentre)*(Kx(kk,0) - xb[][k]) + xb[][k];
                    Sx(kk,1) = (osCoefCentre)*(Kx(kk,1) - yb[][k]) + yb[][k];
            }
                // Construction of a patch-container C around S that is (much) smaller than Omega
                xCL = (floor(Sx(:,0).min/hx)-1)*hx; //we take a small margin around the vertices of S as computed above

                xCR = (ceil(Sx(:,0).max/hx)+1)*hx;

                yCL = (floor(Sx(:,1).min/hy)-1)*hy;

                yCR = (ceil(Sx(:,1).max/hy)+1)*hy;

                xCL = max(0.,xCL); //ensure that the patch-container is a subset of the global domain
                xCR = min(Lx, xCR);
                yCL = max(0., yCL);
                yCR = min(Ly, yCR);

            }
    }


    real dxC = xCR - xCL;
    int dxCn = lrint(dxC/hx); //integer closest to dxC/hx -- ensures that the mesh C defined below is compatible with Th
    real dyC = yCR - yCL;
    int dyCn = lrint(dyC/hy);

    mesh C=square(dxCn, dyCn, [xCL + dxC*x, yCL + dyC*y]);
    fespace VC(C, P1);


    // Construction of the actual coarse mesh element K inside of the patch
    int[int] S2K;
    mesh K=trunc(C,vk>0.5,split=1,label=1,new2old=S2K); 
    fespace VK(K,P1);
    fespace VKVK(K,[P1,P1]);
    int[int] RS2K = restrict(VK,VC,S2K); //array for the restriction of a function on S to K

    if (debug){
        plot(C, vk, fill=1, cmm="Mesh element and oversampling patch", wait=1);
        plot(C, K, cmm="Coarse mesh element", wait=1);
        VC aplotS1=Aeps1(x,y);
        plot(aplotS1, value=1, cmm="Diffusion coefficient 1 on S", wait=1);
        }
    //printmessage("moyenne de sigmaeps sur le patch S : " << int2d(C)(sigmaeps)/int2d(C)(1));
    //printmessage("moyenne de a sur le patch S : " << int2d(C)(Aeps)/int2d(C)(1));
    // Problem
    varf oploc11 (u,v)
            = int2d(C)(FiltrePhi((x-xCL)/dxC,(y-yCL)/dyC)*(sigmaeps1*u*v))
            + int2d(C)(eps^2*FiltrePhi((x-xCL)/dxC,(y-yCL)/dyC)*a(Aeps1,u,v))
            ;
    varf oploc22 (u,v)
            = int2d(C)(FiltrePhi((x-xCL)/dxC,(y-yCL)/dyC)*(sigmaeps4*u*v))
            + int2d(C)(eps^2*FiltrePhi((x-xCL)/dxC,(y-yCL)/dyC)*a(Aeps2,u,v))
            ;

    varf oploc12 (u,v)
            = int2d(C)(FiltrePhi((x-xCL)/dxC,(y-yCL)/dyC)*(sigmaeps2*u)*v)
            ;

    varf oploc21 (u,v)
            = int2d(C)(FiltrePhi((x-xCL)/dxC,(y-yCL)/dyC)*(sigmaeps3*u)*v)
            ;

    varf bloc (u,v) = int2d(C)(FiltrePhi((x-xCL)/dxC,(y-yCL)/dyC)*u*v); //no boundary condition

    varf CLXfiltreloc (u, v)
        = int2d(C)(FiltrePhi((x-xCL)/dxC,(y-yCL)/dyC)*1*dx(v)) 
        ;
    varf CLYfiltreloc (u,v)
        = int2d(C)(FiltrePhi((x-xCL)/dxC,(y-yCL)/dyC)*1*dy(v)) 
        ;

    matrix<real> A11 = oploc11(VC, VC, factorize=1); 
    matrix<real> A22 = oploc22(VC, VC, factorize=1);
    matrix<real> A12 = oploc12(VC, VC, factorize=1);
    matrix<real> A21 = oploc21(VC, VC, factorize=1);
    matrix<real> B = bloc(VC, VC, solver=CG, eps=1e-20);

    real[int] CLXfiltreloclocS1 = CLXfiltreloc(0, VC); 
    real[int] CLYfiltreloclocS1 = CLYfiltreloc(0, VC);

    real[int] Zeros = 0*CLXfiltreloclocS1;

    matrix CLXfiltreloclocS11(2*(CLXfiltreloclocS1.n),1); CLXfiltreloclocS11 = [[CLXfiltreloclocS1], [Zeros]];
    matrix CLYfiltreloclocS11(2*(CLYfiltreloclocS1.n),1); CLYfiltreloclocS11 = [[CLYfiltreloclocS1], [Zeros]];
    matrix CLXfiltreloclocS12(2*(CLXfiltreloclocS1.n),1); CLXfiltreloclocS12 = [ [Zeros], [CLXfiltreloclocS1]];
    matrix CLYfiltreloclocS12(2*(CLYfiltreloclocS1.n),1); CLYfiltreloclocS12 = [ [Zeros], [CLYfiltreloclocS1]];
    matrix MatZeros = 0*A11;


    matrix AlocStmp(2*(A11.n)+4,2*(A11.n)+4);
    matrix AlocStmpadjoint(2*(A11.n)+4,2*(A11.n)+4);
    matrix BlocStmp(2*(A11.n)+4,2*(A11.n)+4);
    AlocStmp = [ [A11 , A12 , CLXfiltreloclocS1 , CLYfiltreloclocS1, Zeros, Zeros] , [A21 , A22 , Zeros, Zeros, CLXfiltreloclocS1 , CLYfiltreloclocS1] , [CLXfiltreloclocS1' ,Zeros',0, 0, 0, 0] , [CLYfiltreloclocS1',Zeros',0, 0, 0, 0] , [Zeros', CLXfiltreloclocS1',0, 0, 0, 0] , [Zeros', CLYfiltreloclocS1',0, 0, 0, 0] ];
    AlocStmpadjoint = [ [A11 , A21 , CLXfiltreloclocS1 , CLYfiltreloclocS1, Zeros, Zeros] , [A12 , A22 , Zeros, Zeros, CLXfiltreloclocS1 , CLYfiltreloclocS1] , [CLXfiltreloclocS1' ,Zeros',0, 0, 0, 0] , [CLYfiltreloclocS1',Zeros',0, 0, 0, 0] , [Zeros', CLXfiltreloclocS1',0, 0, 0, 0] , [Zeros', CLYfiltreloclocS1',0, 0, 0, 0] ];

    BlocStmp = [ [B , MatZeros , Zeros , Zeros, Zeros, Zeros] , [MatZeros , B , Zeros, Zeros, Zeros, Zeros] , [Zeros',Zeros',0, 0, 0, 0] , [Zeros',Zeros',0, 0, 0, 0] , [Zeros', Zeros',0, 0, 0, 0] , [Zeros', Zeros',0, 0, 0, 0] ];

    Mat Aloctemp = AlocStmp;
    Mat Aloctempadjoint = AlocStmpadjoint;
    Mat Bloctemp = BlocStmp; 

    real[int] Listelambdaloc(1); //to store the nev eigenvalue (nev = 1 ici)
    real[int,int] ListeVecteurproprelocS(AlocStmp.n,1) ; //to store the nev eigenvector

    int kloc = EPSSolve(Aloctemp, Bloctemp, values=Listelambdaloc , array=ListeVecteurproprelocS, sparams= ssparamsfiltre); //Résolution du pb aux vp
    kloc=min(kloc,1);

    VC VecteurproprelocS1, VecteurproprelocS2;

    VecteurproprelocS1[](0:VecteurproprelocS1.n-1) = ListeVecteurproprelocS(0:VecteurproprelocS1.n-1,0);
    VecteurproprelocS2[](0:VecteurproprelocS2.n-1) = ListeVecteurproprelocS(VecteurproprelocS1.n:ListeVecteurproprelocS.n-3,0);
    
    real LagrangeMultiplier1 = ListeVecteurproprelocS(ListeVecteurproprelocS.n-2,0);
    real LagrangeMultiplier2 = ListeVecteurproprelocS(ListeVecteurproprelocS.n-1 ,0);

    VC absVecteurproprelocS1 = abs(VecteurproprelocS1);
    if (VecteurproprelocS1[].max/absVecteurproprelocS1[].max<0.9)
    {
        VecteurproprelocS1 = -VecteurproprelocS1;
    }
    VC absVecteurproprelocS2 = abs(VecteurproprelocS2);
    if (VecteurproprelocS2[].max/absVecteurproprelocS2[].max<0.9)
    {
        VecteurproprelocS2 = -VecteurproprelocS2;
    }


    // Renormalisation
    VK VecteurproprelocK1=0; VK VecteurproprelocK2=0;

    VecteurproprelocK1[] = VecteurproprelocS1[](RS2K);
    VecteurproprelocK2[] = VecteurproprelocS2[](RS2K);

    VK produittmp = VecteurproprelocK1*VecteurproprelocK1 + VecteurproprelocK2*VecteurproprelocK2;
    real normeL2VecteurproprelocK=sqrt(int2d(K)(produittmp)/int2d(K)(1));
    VecteurproprelocK1[] = VecteurproprelocK1[]/(normeL2VecteurproprelocK);
    VecteurproprelocK2[] = VecteurproprelocK2[]/normeL2VecteurproprelocK;

    real[int] Listelambdalocadjoint(1); //to store the nev eigenvalue (nev = 1 ici)
    real[int,int] ListeVecteurproprelocSadjoint(AlocStmpadjoint.n,1) ; //to store the nev eigenvector

    int klocadjoint = EPSSolve(Aloctempadjoint, Bloctemp, values=Listelambdalocadjoint , array=ListeVecteurproprelocSadjoint, sparams= ssparamsfiltre); //Résolution du pb aux vp
    klocadjoint=min(klocadjoint,1);

    VC VecteurproprelocSadjoint1, VecteurproprelocSadjoint2;

    VecteurproprelocSadjoint1[](0:VecteurproprelocSadjoint1.n-1) = ListeVecteurproprelocSadjoint(0:VecteurproprelocSadjoint1.n-1,0);
    VecteurproprelocSadjoint2[](0:VecteurproprelocSadjoint2.n-1) = ListeVecteurproprelocSadjoint(VecteurproprelocSadjoint1.n:ListeVecteurproprelocSadjoint.n-3,0);

    VC absVecteurproprelocSadjoint1 = abs(VecteurproprelocSadjoint1);
    if (VecteurproprelocSadjoint1[].max/absVecteurproprelocSadjoint1[].max<0.9)
    {
        VecteurproprelocSadjoint1 = -VecteurproprelocSadjoint1;
    }
    VC absVecteurproprelocSadjoint2 = abs(VecteurproprelocSadjoint2);
    if (VecteurproprelocSadjoint2[].max/absVecteurproprelocSadjoint2[].max<0.9)
    {
        VecteurproprelocSadjoint2 = -VecteurproprelocSadjoint2;
    }

    VK VecteurproprelocKadjoint1=0; VK VecteurproprelocKadjoint2=0;
    VecteurproprelocKadjoint1[] = VecteurproprelocSadjoint1[](RS2K);
    VecteurproprelocKadjoint2[] = VecteurproprelocSadjoint2[](RS2K);
    // Renormalisation
    VK produittmpadjoint = VecteurproprelocKadjoint1*VecteurproprelocKadjoint1 + VecteurproprelocKadjoint2*VecteurproprelocKadjoint2;
    real normeL2VecteurproprelocKadjoint=sqrt(int2d(K)(produittmpadjoint)/int2d(K)(1));
    VecteurproprelocKadjoint1[] = VecteurproprelocKadjoint1[]/normeL2VecteurproprelocKadjoint;
    VecteurproprelocKadjoint2[] = VecteurproprelocKadjoint2[]/normeL2VecteurproprelocKadjoint;


    if (k==20 && plots) {
        plot(C, vk, fill=1, cmm="Mesh element and oversampling patch", wait=1);
        plot(C, K, cmm="Coarse mesh element", wait=1);
        VC aplotS=Aeps1(x,y);
        VC sigmaplotS = sigmaeps1(x,y);
        plot(aplotS, value=1, cmm="Diffusion coefficient on S", wait=1);
        plot(sigmaplotS, value=1, cmm="Sigma coefficient on S", wait=1);
        plot(VecteurproprelocS1, fill=1, value=1, cmm="Premier vecteur propre Energie 1", wait=1);
        plot(VecteurproprelocS2, fill=1, value=1, cmm="Premier vecteur propre Energie 2", wait=1);
        plot(VecteurproprelocK1, fill=1, value=1, cmm="Vecteur propre loc K Energie 1", wait=1);
        plot(VecteurproprelocK2, fill=1, value=1, cmm="Vecteur propre loc K Energie 2", wait=1);
        plot(VecteurproprelocKadjoint1, fill=1, value=1, cmm="Premier vecteur propre adjoint Energie 1", wait=1);
        plot(VecteurproprelocKadjoint2, fill=1, value=1, cmm="Premier vecteur propre adjoint Energie 2", wait=1);

    }
    //Construction des 3 fonctions de forme associées à l'élément K
    VK[int] phi(3); //storage of local basis function contributions in the offline loop
    // Resolution of local problems
    varf defMS([uh1,uh2],[vh1,vh2]) = 

        int2d(K)(eps^2*VecteurproprelocK1*VecteurproprelocKadjoint1*a(Aeps1,uh1,vh1)) // D_eps
        + int2d(K)(eps^2*VecteurproprelocK2*VecteurproprelocKadjoint2*a(Aeps2,uh2,vh2))

        + int2d(K)(VecteurproprelocK2*VecteurproprelocKadjoint1*sigmaeps2*(uh2 - uh1)*vh1) //Q_tilde_eps
        + int2d(K)(VecteurproprelocK1*VecteurproprelocKadjoint2*sigmaeps3*(uh1 - uh2)*vh2)

        + int2d(K)(eps^2*Aeps1*(VecteurproprelocK1*dx(VecteurproprelocKadjoint1)-VecteurproprelocKadjoint1*dx(VecteurproprelocK1))*dx(uh1)*vh1) //J_eps
        + int2d(K)(eps^2*Aeps1*(VecteurproprelocK1*dy(VecteurproprelocKadjoint1)-VecteurproprelocKadjoint1*dy(VecteurproprelocK1))*dy(uh1)*vh1)
        + int2d(K)(eps^2*Aeps2*(VecteurproprelocK2*dx(VecteurproprelocKadjoint2)-VecteurproprelocKadjoint2*dx(VecteurproprelocK2))*dx(uh2)*vh2)
        + int2d(K)(eps^2*Aeps2*(VecteurproprelocK2*dy(VecteurproprelocKadjoint2)-VecteurproprelocKadjoint2*dy(VecteurproprelocK2))*dy(uh2)*vh2)
        
        + int1d(K)(tgv*uh1*vh1 + tgv*uh2*vh2); // Dirichlet boundary condition;
        
	matrix Aloc=defMS(VKVK,VKVK);
	set(Aloc, solver=UMFPACK);
	VH bc=0; //will hold the boundary condition for local problems

	VK[int] Phi11(3) ; VK[int] Phi12(3); //storage of local basis function contributions in the offline loop;
	VK[int] Phi21(3) ; VK[int] Phi22(3); //storage of local basis function contributions in the offline loop;	
	for (int i=0; i<3; i++) {

        VKVK [phiC11,phiC12]; //storage of local basis function contributions in the offline loop
        VKVK [phiC21,phiC22]; //storage of local basis function contributions in the offline loop
		
        int dofi = VH(k,i); // the index in VH associated to vertex i of triangle k
		bc[][dofi] = 1;
        varf rhsloc1([uh1,uh2],[vh1,vh2]) = int1d(K)(tgv*bc*vh1);
        varf rhsloc2([uh1,uh2],[vh1,vh2]) = int1d(K)(tgv*bc*vh2);
		real[int] Bloc1 = rhsloc1(0,VKVK);
        real[int] Bloc2 = rhsloc2(0,VKVK);
		phiC11[] = Aloc^-1*Bloc1;
        phiC21[] = Aloc^-1*Bloc2;
		bc[][dofi]=0;

        if (debug){
            plot(phiC11,wait=1,value=1,fill=1, cmm="fonction forme Chi 1");
			plot(phiC12,wait=1,value=1,fill=1, cmm="fonction forme Chi 2");
            plot(phiC21,wait=1,value=1,fill=1, cmm="fonction forme Chi 1");
            plot(phiC22,wait=1,value=1,fill=1, cmm="fonction forme Chi 2");
        }
		int storei = 0;
		storei = storeIndex(k,i);

		VK phiC11Psieps1 = phiC11*VecteurproprelocK1;
        VK phiC12Psieps2 = phiC12*VecteurproprelocK2;
        VK phiC21Psieps1 = phiC21*VecteurproprelocK1;
        VK phiC22Psieps2 = phiC22*VecteurproprelocK2;

		Phi11[i][] = phiC11Psieps1[];
		Phi22[i][] = phiC22Psieps2[];
		Phi12[i][] = phiC12Psieps2[];
		Phi21[i][] = phiC21Psieps1[];

		if (debug){
			plot(Phi11[i],wait=1,value=1,fill=1, cmm="fonction forme Chi Psi 1");	
			plot(Phi22[i],wait=1,value=1,fill=1, cmm="fonction forme Chi Psi 2");		
		}
		phiEps11[storei][] = Phi11[i][]; // save basis functions for multiscale reconstruction below
		phiEps12[storei][] = Phi12[i][]; // save basis functions for multiscale reconstruction below
		phiEps21[storei][] = Phi21[i][]; // save basis functions for multiscale reconstruction below
		phiEps22[storei][] = Phi22[i][]; // save basis functions for multiscale reconstruction below
	}
	// Computation of matrix elements
	for (int j=0; j<3; j++)
	{ //loop over all corners for matrix contributions on K
		for (int i=0; i<3; i++) {
			// int ii = contr[i]; // seems superfluous ???
			// Find global DOF index for trial functions j and test function i,
			// compute matrix contributions,
			// save these in Imat[nnz], Jmat[nnz] and Mmat[nnz]
            if (recombinebool){
                Imat[nnz] = VH(recombine(k,Ntri),i);
			    Jmat[nnz] = VH(recombine(k,Ntri),j);
            } else {
                Imat[nnz] = VH(k,i);
			    Jmat[nnz] = VH(k,j);
            }
            //}
			Amat11[nnz] = int2d(K)(eps^2*a(Aeps1, Phi11[i], Phi11[j])) + int2d(K)(eps^2*a(Aeps2, Phi12[i], Phi12[j]));
            Amat12[nnz] = int2d(K)(eps^2*a(Aeps1, Phi11[i], Phi21[j])) + int2d(K)(eps^2*a(Aeps2, Phi12[i], Phi22[j]));
            Amat21[nnz] = int2d(K)(eps^2*a(Aeps2, Phi22[i], Phi12[j])) + int2d(K)(eps^2*a(Aeps1, Phi21[i], Phi11[j]));
			Amat22[nnz] = int2d(K)(eps^2*a(Aeps2, Phi22[i], Phi22[j])) + int2d(K)(eps^2*a(Aeps1, Phi21[i], Phi21[j]));

			Sigmamat11[nnz] = int2d(K)(sigmaeps1*Phi11[i]*Phi11[j]) + int2d(K)(sigmaeps2*Phi11[i]*Phi12[j])
                            + int2d(K)(sigmaeps3*Phi12[i]*Phi11[j]) + int2d(K)(sigmaeps4*Phi12[i]*Phi12[j]);

            Sigmamat12[nnz] = int2d(K)(sigmaeps1*Phi11[i]*Phi21[j]) + int2d(K)(sigmaeps2*Phi11[i]*Phi22[j])
                            + int2d(K)(sigmaeps3*Phi12[i]*Phi21[j]) + int2d(K)(sigmaeps4*Phi12[i]*Phi22[j]);

            Sigmamat21[nnz] = int2d(K)(sigmaeps1*Phi21[i]*Phi11[j]) + int2d(K)(sigmaeps2*Phi21[i]*Phi12[j])
                            + int2d(K)(sigmaeps3*Phi22[i]*Phi11[j]) + int2d(K)(sigmaeps4*Phi22[i]*Phi12[j]);

            Sigmamat22[nnz] = int2d(K)(sigmaeps1*Phi21[i]*Phi21[j]) + int2d(K)(sigmaeps2*Phi21[i]*Phi22[j])
                            + int2d(K)(sigmaeps3*Phi22[i]*Phi21[j]) + int2d(K)(sigmaeps4*Phi22[i]*Phi22[j]);

            Bmat11[nnz] = int2d(K)(Phi11[i]*Phi11[j]) + int2d(K)(Phi12[i]*Phi12[j]);
            Bmat21[nnz] = int2d(K)(Phi21[i]*Phi11[j]) + int2d(K)(Phi22[i]*Phi12[j]);
            Bmat12[nnz] = int2d(K)(Phi11[i]*Phi21[j]) + int2d(K)(Phi12[i]*Phi22[j]);
			Bmat22[nnz] = int2d(K)(Phi22[i]*Phi22[j]) + int2d(K)(Phi21[i]*Phi21[j]);
			nnz++;
		}
	}
	vk[][k]=0;
}
toc = clock();

printmessage("Temps de construction des fonctions de forme : " << toc - tic << " secondes ");

///////////////////////////////////////////////////////////////////////
// Online stage                                                      //
///////////////////////////////////////////////////////////////////////
tic = clock();


// Define global matrix and add boundary conditions to the system by penalization
matrix Amsfem11 = [Imat(0:nnz-1), Jmat(0:nnz-1), Amat11(0:nnz-1)];
matrix Amsfem12 = [Imat(0:nnz-1), Jmat(0:nnz-1), Amat12(0:nnz-1)];
matrix Amsfem21 = [Imat(0:nnz-1), Jmat(0:nnz-1), Amat21(0:nnz-1)];
matrix Amsfem22 = [Imat(0:nnz-1), Jmat(0:nnz-1), Amat22(0:nnz-1)];
matrix Bmsfem11 = [Imat(0:nnz-1), Jmat(0:nnz-1), Bmat11(0:nnz-1)];
matrix Bmsfem12 = [Imat(0:nnz-1), Jmat(0:nnz-1), Bmat12(0:nnz-1)];
matrix Bmsfem21 = [Imat(0:nnz-1), Jmat(0:nnz-1), Bmat21(0:nnz-1)];
matrix Bmsfem22 = [Imat(0:nnz-1), Jmat(0:nnz-1), Bmat22(0:nnz-1)];
matrix Sigmamsfem11 = [Imat(0:nnz-1), Jmat(0:nnz-1), Sigmamat11(0:nnz-1)];
matrix Sigmamsfem12 = [Imat(0:nnz-1), Jmat(0:nnz-1), Sigmamat12(0:nnz-1)];
matrix Sigmamsfem21 = [Imat(0:nnz-1), Jmat(0:nnz-1), Sigmamat21(0:nnz-1)];
matrix Sigmamsfem22 = [Imat(0:nnz-1), Jmat(0:nnz-1), Sigmamat22(0:nnz-1)];
matrix Zeros((Amsfem11.n), (Amsfem11.n)) ;
Zeros=Zeros*0;

varf boundarycondition(u,v) = int1d(TH)(tgv*u*v);
matrix Abc = boundarycondition(VH,VH);

matrix Aglob(2*(Amsfem11.n), 2*(Amsfem11.n));
matrix Bglob(2*(Amsfem11.n), 2*(Amsfem11.n));

matrix Aglob11 = Amsfem11 + Sigmamsfem11 + Abc;
matrix Aglob22 = Amsfem22 + Sigmamsfem22 + Abc;
matrix Aglob12 = Sigmamsfem12 + Amsfem12;
matrix Aglob21 = Sigmamsfem21 + Amsfem21;

Aglob = [ [Aglob11, Aglob12] , [Aglob21, Aglob22] ];

Bglob = [ [Bmsfem11, Bmsfem12] , [Bmsfem21, Bmsfem22] ];

Mat Amsfemtemp = Aglob;
Mat Bmsfemtemp = Bglob;

real[int] Listelambdamsfem(NumberEigenValue); //to store the nev eigenvalue
real[int,int] ListeVecteurpropremsfem(Aglob.n,1) ; //to store the nev eigenvector


int kmsfem = EPSSolve(Amsfemtemp, Bmsfemtemp, array = ListeVecteurpropremsfem, values  = Listelambdamsfem, sparams = ssparams); //Résolution du pb aux vp
kmsfem=min(kmsfem,NumberEigenValue); // il arrive apparement qu'il n'y a pas que la 1ere vp renvoyee de cette fonction

real lambdaH = Listelambdamsfem[NumberEigenValue-1]; //La fonction EPSSolve n'a l'air de vouloir que des vecteurs des valeurs propres et vectpropres
cout << "lambdaH" << lambdaH << endl;
VH Vecteurpropremsfem1, Vecteurpropremsfem2;
Vecteurpropremsfem1[](0:Vecteurpropremsfem1.n-1) = ListeVecteurpropremsfem(0:Vecteurpropremsfem1.n-1,0);
Vecteurpropremsfem2[](0:Vecteurpropremsfem2.n-1) = ListeVecteurpropremsfem(Vecteurpropremsfem1.n:ListeVecteurpropremsfem.n-1,0);


VH absVecteurpropremsfem1 = abs(Vecteurpropremsfem1);
if (Vecteurpropremsfem1[].max/absVecteurpropremsfem1[].max<0.9)
{
    Vecteurpropremsfem1 = -Vecteurpropremsfem1;
}
VH absVecteurpropremsfem2 = abs(Vecteurpropremsfem2);
if (Vecteurpropremsfem2[].max/absVecteurpropremsfem2[].max<0.9)
{
    Vecteurpropremsfem2 = -Vecteurpropremsfem2;
}

toc = clock();

printmessage("Temps de resolution online du probleme MsFEM : " << toc - tic << " secondes ");
printmessage("lambda_MsFEM_" << nameMethod << " = " << lambdaH);

///////////////////////////////////////////////////////////////////////
// Reconstruction of the MsFEM solution on the fine scale            //
///////////////////////////////////////////////////////////////////////
printmessage("Reconstruction of the MsFEM solution on the fine scale");
tic = clock();


Vh VecteurpropreHProjetee1=0; //multiscale solution
Vh VecteurpropreHProjetee2=0; //multiscale solution
for (int k=0; k<Ntri; k++)
{// Loop over all elements to reuse the multiscale information of the offline stage
	vk[][k]=1;
	int[int] n2oFine;
	mesh Kh=trunc(Th, vk>0.5, split=1, new2old=n2oFine); //mesh for the resolution of MsFEM solution
	fespace VK(Kh,P1);
	int[int] loc2globFine = restrict(VK, Vh, n2oFine);
	
	real[int] uhloc1(VK.ndof);
    real[int] uhloc2(VK.ndof);
	for (int i=0; i<3; i++) {
		int dofi = VH(k,i);
		int storei = storeIndex(k,i);
		uhloc1 += Vecteurpropremsfem1[][dofi]*phiEps11[storei][] + Vecteurpropremsfem2[][dofi]*phiEps21[storei][];
        uhloc2 += Vecteurpropremsfem2[][dofi]*phiEps22[storei][] + Vecteurpropremsfem1[][dofi]*phiEps12[storei][];
	}
	
	VecteurpropreHProjetee1[](loc2globFine) = uhloc1; // Etant donné que on met ici "=" et non "+=", On perd des informations sur les bords
    VecteurpropreHProjetee2[](loc2globFine) = uhloc2;
    // Mais on ne peut pas mettre "+=" directement, car dans ce cas les valeurs au bord s'ajouteraient.
    	
	vk[][k]=0;
}


// Renormalisation
real normeL2msfem=sqrt(int2d(Th)(VecteurpropreHProjetee1*VecteurpropreHProjetee1 + VecteurpropreHProjetee2*VecteurpropreHProjetee2));
VecteurpropreHProjetee1[] = VecteurpropreHProjetee1[]/normeL2msfem;
VecteurpropreHProjetee2[] = VecteurpropreHProjetee2[]/normeL2msfem;

Vecteurpropremsfem1[] = Vecteurpropremsfem1[]/normeL2msfem;
Vecteurpropremsfem2[] = Vecteurpropremsfem2[]/normeL2msfem;

toc = clock();
printmessage("Temps de reconstruction of the MsFEM solution on the fine scale : " << toc - tic << " secondes ");

if (debug) plot(Vecteurpropremsfem1, fill=1, value=1, wait=1, cmm="MsFEM solution (coarse mesh) Energie 1");
if (debug) plot(Vecteurpropremsfem2, fill=1, value=1, wait=1, cmm="MsFEM solution (coarse mesh) Energie 2");

if (plots) plot(VecteurpropreHProjetee1, fill=1, value=1, wait=1, cmm="MsFEM solution (fine mesh) Energie 1");
if (plots) plot(VecteurpropreHProjetee2, fill=1, value=1, wait=1, cmm="MsFEM solution (fine mesh) Energie 2");


///////////////////////////////////////////////////////////////////////
// Reference solution and error computation                          //
///////////////////////////////////////////////////////////////////////
/*
// Load or compute reference solution
 if (ErreurSurK) {
	{
		string solname = "./Solutions_reference/sol_" + nameMethod + parametersREF + ".txt";
		ofstream ff(solname);
		ff << VecteurpropreHProjetee[] << endl;
		ff << endl;
	}
}*/

///////////////////////////////////////////////////////////////////////
// POST-PROCESSING                                                   //
// (msfem_blocks/post.idp)                                           //
///////////////////////////////////////////////////////////////////////
string name = "REF";

///////////////////////////////////////////////////////////////////////
// Reference solution and error computation                          //
///////////////////////////////////////////////////////////////////////

// Load or compute reference solution
tic = clock();

printmessage("WARNING: No reference solution was found and it is recomputed");
// Problem
real lambdaref;
Vh Vecteurpropreref1, Vecteurpropreref2;
// Problem
varf opref ([uref1,uref2], [vh1,vh2])  
    = int2d(Th)(eps^2*a(Aeps1,uref1,vh1))
    + int2d(Th)(eps^2*a(Aeps2,uref2,vh2))
    + int2d(Th)((sigmaeps1*uref1 + sigmaeps2*uref2)*vh1
          +(sigmaeps3*uref1 + sigmaeps4*uref2)*vh2) 
    + on(1, 2, 3, 4, uref1=0)
    + on(1, 2, 3, 4, uref2=0)
    ;

varf bref ([uref1,uref2], [vh1,vh2]) = int2d(Th)(uref1*vh1 + uref2*vh2); //no boundary condition

matrix<real> Aref = opref(VhVh, VhVh, factorize=1); 
matrix<real> Bref = bref(VhVh, VhVh, solver=CG, eps=1e-20);

Mat Areftemp = Aref;
Mat Breftemp = Bref;

real[int] Listelambdaref(NumberEigenValue); //to store the nev eigenvalue (nev = 1 ici)
VhVh[int] [ListeVecteurpropreref1,ListeVecteurpropreref2](NumberEigenValue); //to store the nev eigenvector


int kref = EPSSolve(Areftemp, Breftemp, vectors = ListeVecteurpropreref1, values  = Listelambdaref, sparams = ssparams); //Résolution du pb aux vp
kref=min(kref,NumberEigenValue);

toc = clock();

lambdaref = Listelambdaref[NumberEigenValue-1]; //La fonction EPSSolve n'a l'air de vouloir que des vecteurs des valeurs propres et vectpropres

cout << "lambdaref = " << lambdaref << endl;

Vecteurpropreref1 = ListeVecteurpropreref1[NumberEigenValue-1];
Vecteurpropreref2 = ListeVecteurpropreref2[NumberEigenValue-1];


Vh absVecteurpropreref1; absVecteurpropreref1 = abs(Vecteurpropreref1);
if (Vecteurpropreref1[].max/absVecteurpropreref1[].max<0.9)
{
    Vecteurpropreref1 = -Vecteurpropreref1;
}
Vh absVecteurpropreref2 = abs(Vecteurpropreref2);
if (Vecteurpropreref2[].max/absVecteurpropreref2[].max<0.9)
{
    Vecteurpropreref2 = -Vecteurpropreref2;
}

// Renormalisation
real normeL2ref=sqrt(int2d(Th)(Vecteurpropreref1*Vecteurpropreref1 + Vecteurpropreref2*Vecteurpropreref2));
Vecteurpropreref1[] = Vecteurpropreref1[]/normeL2ref;
Vecteurpropreref2[] = Vecteurpropreref2[]/normeL2ref;

//toc = clock();

printmessage("Temps de calcul de la solution de reference : " << toc - tic << " secondes ");
printmessage("lambda_" << nameMethod << " = " << lambdaref);

if (plots) plot(Vecteurpropreref1,wait=1,value=1,fill=1, cmm="Solution de reference Energie 1");

if (plots) plot(Vecteurpropreref2,wait=1,value=1,fill=1, cmm="Solution de reference Energie 2");

printmessage("Calcul des erreurs et stockage dans un fichier");
tic = clock();

// Compute norms of reference solution
real nL11=0, nL21=0, nH11=0, nMoy1=0, nMax1=0;
real nL12=0, nL22=0, nH12=0, nMoy2=0, nMax2=0;
nL11=sqrt(int2d(Th)(Vecteurpropreref1));
nL12=sqrt(int2d(Th)(Vecteurpropreref2));
nL21=sqrt(int2d(Th)(Vecteurpropreref1*Vecteurpropreref1));
nL22=sqrt(int2d(Th)(Vecteurpropreref2*Vecteurpropreref2));
nMax1=Vecteurpropreref1[].max;
nMax2=Vecteurpropreref2[].max;
string printNorms = "norms: " + nL11 + "  " + nL21 + "  " + nH11 + "  " + nMax1;

// Compute errors and relative errors
Vh e1=0;
Vh e2=0;
Vh ErreurH1SansBordK1 = 0;
Vh ErreurH1SansBordK2 = 0;
real eL11, eL12, eL21, eL22, eH11, eH12, eMax1, eMax2, elambda, eMoy1, eMoy2, erL11, erL12, erL21, erL22, erH11, erH12, erMax1, erMax2, erlambda, erMoy1, erMoy2;
real eGlobalL2, eGlobalH1, eGlobalMax;
for(int k=0; k<Ntri; k++) {

    vk[][k]=1;
    int[int] n2oFine;
	mesh Kh=trunc(Th, vk>0.5, split=1, new2old=n2oFine);
    fespace VK(Kh,P1);
	int[int] loc2globFine = restrict(VK, Vh, n2oFine);
    
    VK errK1=0;
    VK errK2=0;
    if (nameMethod=="P1") {
        VK f11 = 0; f11[] = VecteurpropreHProjetee1[](loc2globFine);
        VK f12 = 0; f12[] = Vecteurpropreref1[](loc2globFine);
        errK1[] = f12[] - f11[];
        VK f21 = 0; f21[] = VecteurpropreHProjetee2[](loc2globFine);
        VK f22 = 0; f22[] = Vecteurpropreref2[](loc2globFine);
        errK2[] = f22[] - f21[];

    }else { // Je separe les cas car sur le bord du triangle, il faut bien que la valeur de Uhloc_K soit celle correspondant a la fonction de forme sur K et pas celle d'a cote (voir fin de online.MsFEM pour mieux comprendre)
        //VK f1 = 0; f1[] = VecteurpropreHProjetee[](loc2globFine);
        real[int] uhloc1(VK.ndof);
        real[int] uhloc2(VK.ndof);
        for (int i=0; i<3; i++) {
            int dofi = VH(k,i);
            int storei = storeIndex(k,i);
            uhloc1 += Vecteurpropremsfem1[][dofi]*phiEps11[storei][] + Vecteurpropremsfem2[][dofi]*phiEps21[storei][];
            uhloc2 += Vecteurpropremsfem2[][dofi]*phiEps22[storei][] + Vecteurpropremsfem1[][dofi]*phiEps12[storei][];
        }

        errK1[] = Vecteurpropreref1[](loc2globFine);
        errK1[] = errK1[] - uhloc1;
        errK2[] = Vecteurpropreref2[](loc2globFine);
        errK2[] = errK2[] - uhloc2;

        VK errKH11 = 0;
        errKH11 = dx(errK1)*dx(errK1) + dy(errK1)*dy(errK1);
        ErreurH1SansBordK1[](loc2globFine) = errKH11[];
        VK errKH12 = 0;
        errKH12 = dx(errK2)*dx(errK2) + dy(errK2)*dy(errK2);
        ErreurH1SansBordK2[](loc2globFine) = errKH12[];
    }

    e1[](loc2globFine) = errK1[];
    e2[](loc2globFine) = errK2[];
    VK VecteurproprerefK1 = 0;
    VK VecteurproprerefK2 = 0;
    VecteurproprerefK1[] = Vecteurpropreref1[](loc2globFine);
    VecteurproprerefK2[] = Vecteurpropreref2[](loc2globFine);
    
    nMoy1+=int2d(Kh)(VecteurproprerefK1)*int2d(Kh)(VecteurproprerefK1);
    nMoy2+=int2d(Kh)(VecteurproprerefK2)*int2d(Kh)(VecteurproprerefK2);


    // Error computations on K
    
    eL11+=int2d(Kh)(abs(errK1));
    eL12+=int2d(Kh)(abs(errK2));
    
    eL21+=int2d(Kh)(errK1*errK1);
    eL22+=int2d(Kh)(errK2*errK2);
    
    eH11+=int2d(Kh)(dx(errK1)*dx(errK1)+dy(errK1)*dy(errK1) + errK1*errK1);
    eH12+=int2d(Kh)(dx(errK2)*dx(errK2)+dy(errK2)*dy(errK2) + errK2*errK2);
    nH11+=int2d(Kh)(VecteurproprerefK1*VecteurproprerefK1 + dx(VecteurproprerefK1)*dx(VecteurproprerefK1) + dy(VecteurproprerefK1)*dy(VecteurproprerefK1));
    nH12+=int2d(Kh)(VecteurproprerefK2*VecteurproprerefK2 + dx(VecteurproprerefK2)*dx(VecteurproprerefK2) + dy(VecteurproprerefK2)*dy(VecteurproprerefK2));

    eMoy1+=int2d(Kh)(errK1)*int2d(Kh)(errK1);
    eMoy2+=int2d(Kh)(errK2)*int2d(Kh)(errK2);
    
    errK1=abs(errK1);
    errK2=abs(errK2);

    eMax1=max(errK1[].max,eMax1);
    eMax2=max(errK2[].max,eMax2);

    vk[][k]=0;
}
// Taking square roots, determining the relative errors

eL21 = sqrt(eL21);
eH11 = sqrt(eH11);
nH11 = sqrt(nH11);
eL22 = sqrt(eL22);
eH12 = sqrt(eH12);
nH12 = sqrt(nH12);

erL11=eL11/nL11; erL21=eL21/nL21;
erL21=eL21/nL21; erL22=eL22/nL22;
erH11=eH11/nH11; erH12=eH12/nH12;
erMoy1 = sqrt(eMoy1/nMoy1); erMoy2 = sqrt(eMoy2/nMoy2);
erMax1=eMax1/nMax1; erMax2=eMax2/nMax2;

eGlobalL2 = sqrt(erL21^2 + erL22^2)/sqrt(2);
eGlobalH1 = sqrt(erH11^2 + erH12^2)/sqrt(2);
eGlobalMax = max(erMax1,erMax2);

elambda = abs(lambdaH - lambdaref);
erlambda = abs(lambdaH - lambdaref)/lambdaref;

if (plots) plot(e1,wait=1,value=1, cmm="error Energie 1");
if (plots) plot(e2,wait=1,value=1, cmm="error Energie 2");

if (plots) plot(ErreurH1SansBordK1,wait=1,value=1, cmm="error, derivee Energie 1");
if (plots) plot(ErreurH1SansBordK2,wait=1,value=1, cmm="error, derivee Energie 2");

{// Writing errors to an external file
    string errname = "Results/errors_reaction_diffusion_multigroup_" + nameMethod + "_Coeffs_" + NumCoeffDiff + ".txt";
    ofstream ff(errname, append);
    ff  << ParameterDescription
        << endl
        << "\t"
        << "n\t" << n << "\t"
        << "N\t" << Ndiscr << "\t"
        << "eps\t" << eps << "\t"
        << "NumVP\t" << NumberEigenValue << "\t"
        << "osCoef\t" << osCoef << "\t"
        << endl

        << "\t\tL21\t\tL22\t\tH11\t\tH12\t\tmax1\t\tmax2\t\tlambdarel\t\teGlobalL2\t\teGlobalH1\t\teGlobalMax\t\t"
        << endl;        
    
    ff  << "\t\t"
        << erL21 <<"\t"<< erL22 <<"\t"<< erH11 <<"\t"<< erH12 <<"\t"<< erMax1 <<"\t" << erMax2 <<"\t" << erlambda <<"\t"
        <<"\t"<< eGlobalL2 <<"\t"<<"\t"<< eGlobalH1 <<"\t"<<"\t"<< eGlobalMax <<"\t"
        << endl;
    
	ff<<endl;
}
toc = clock();

printmessage("Temps de calcul des erreurs : " << toc - tic << " secondes ");

printmessage("////////////////////////////////////////////////////////////////");
